% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FSelectInstance.R
\name{FSelectInstance}
\alias{FSelectInstance}
\title{FSelectInstance Class}
\description{
Specifies a general feature selection scenario, including objective function
and archive for Optimizers to act upon. This class stores an
\link{ObjectiveFSelect} object that encodes the black box objective function which
an \link{Optimizer} has to optimize. It allows the basic operations of querying
the objective at feature subsets (\verb{$eval_batch()}), stroring the evaluations
in the internal \link{Archive} and accessing the final result (\verb{$result}).

Evaluations of feature subsets are performed in batches by calling
\code{\link[mlr3:benchmark]{mlr3::benchmark()}} internally. Before a batch is evaluated, the \link{Terminator}
is queried for the remaining budget. If the available budget is exhausted, an
exception is raised, and no further evaluations can be performed from this
point on.

The Optimizer object is also supposed to store its final result, consisting
of a selected feature subset and associated estimated performance values, by
calling the method \code{instance$assign_result()}.
}
\examples{
library(mlr3)

# Objects required to define the performance evaluator
task = tsk("iris")
measures = msrs(c("classif.ce"))
learner = lrn("classif.rpart")
resampling = rsmp("cv")
terminator = term("evals", n_evals = 8)

inst = FSelectInstance$new(
  task = task,
  learner = learner,
  resampling = resampling,
  measures = measures,
  terminator = terminator
)
}
\section{Super class}{
\code{\link[bbotk:OptimInstance]{bbotk::OptimInstance}} -> \code{FSelectInstance}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{FSelectInstance$new()}}
\item \href{#method-objective_function}{\code{FSelectInstance$objective_function()}}
\item \href{#method-clone}{\code{FSelectInstance$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="assign_result">}\href{../../bbotk/html/OptimInstance.html#method-assign_result}{\code{bbotk::OptimInstance$assign_result()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="eval_batch">}\href{../../bbotk/html/OptimInstance.html#method-eval_batch}{\code{bbotk::OptimInstance$eval_batch()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format">}\href{../../bbotk/html/OptimInstance.html#method-format}{\code{bbotk::OptimInstance$format()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print">}\href{../../bbotk/html/OptimInstance.html#method-print}{\code{bbotk::OptimInstance$print()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Creates a new instance of this \link[R6:R6Class]{R6} class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FSelectInstance$new(
  task,
  learner,
  resampling,
  measure,
  terminator,
  store_models = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task}}{(\link[mlr3:Task]{mlr3::Task})}

\item{\code{learner}}{(\link[mlr3:Learner]{mlr3::Learner})}

\item{\code{resampling}}{(\link[mlr3:Resampling]{mlr3::Resampling})\cr
Note that uninstantiated resamplings are instantiated during construction
so that all configurations are evaluated on the same data splits.}

\item{\code{measure}}{(\link[mlr3:Measure]{mlr3::Measure})\cr
Measure to optimize.}

\item{\code{terminator}}{(\link{Terminator})}

\item{\code{store_models}}{(\code{logical(1)})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-objective_function"></a>}}
\if{latex}{\out{\hypertarget{method-objective_function}{}}}
\subsection{Method \code{objective_function()}}{
Evaluates a single feature set encoded as 0/1, and returns a
scalar objective value, where the return value is negated if the measure
is maximized. Internally, \verb{$eval_batch()} is called with a single row.
This function serves as a objective function for optimizers of binary
spaces.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FSelectInstance$objective_function(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{(\code{integer()})\cr
0/1 encoded feature set.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Objective value as \code{numeric(1)}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FSelectInstance$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
